<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Wahrheit oder Pflicht</title>
<style>
  body{font-family:Arial,sans-serif;background:#111;color:#fff;text-align:center;padding:20px}
  button{padding:12px 20px;margin:10px;font-size:16px;cursor:pointer}
  select,input{padding:8px;margin:5px}
  .card{margin-top:20px;padding:20px;background:#222;border-radius:10px}
  .hidden{display:none}

  #players > div{margin:8px 0}
  #targetsBox{
    margin-top:10px;font-size:14px;opacity:.92;padding:10px 12px;
    background:#1a1a1a;border:1px solid #333;border-radius:10px;display:none
  }
</style>
</head>
<body>

<h1>Wahrheit oder Pflicht</h1>

<div id="setup">
  <h3>Spieleranzahl</h3>
  <select id="playerCount" onchange="setPlayerCount()">
    <option value="2" selected>2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="8">8</option>
  </select>

  <h2>Spieler hinzufügen</h2>
  <div id="players"></div>

  <h3>Level (exakt)</h3>
  <select id="level">
    <option value="1">1 - Sanft</option>
    <option value="2">2 - Mittel</option>
    <option value="3">3 - Direkt</option>
    <option value="4">4 - Heavy</option>
    <option value="5">5 - Pervers & Dirty</option>
  </select>
  <br><br>

  <button onclick="startGame()">Spiel starten</button>

  <div style="max-width:720px;margin:18px auto 0;opacity:.85;font-size:13px;line-height:1.35">
    CSV-Spalten: <b>type;text;level;wer;allowed;target;timer;zieltyp</b><br>
    allowed/wer/target: <b>alle</b> oder Liste/Wert aus: <b>männlich, weiblich, nonbinär</b> bzw. <b>hetero, homo, bi, pan, offen</b><br>
    zieltyp: <b>Selbst, Einzel, Zwei, Gruppe, BeliebigViele</b>
  </div>
</div>

<div id="game" class="hidden">
  <h2 id="currentPlayer"></h2>

  <button onclick="draw('Wahrheit')">Wahrheit</button>
  <button onclick="draw('Pflicht')">Pflicht</button>

  <div id="result" class="card hidden">
    <p id="taskText"></p>
    <div id="targetsBox"></div>

    <div style="margin-top:12px;">
      <div style="margin-bottom:8px;">
        <button type="button" onclick="setTimerMinutes(1)">1 min</button>
        <button type="button" onclick="setTimerMinutes(3)">3 min</button>
        <button type="button" onclick="setTimerMinutes(5)">5 min</button>
      </div>

      <div style="display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap;">
        <label style="font-size:14px;">
          Minuten:
          <input id="timerInputMinutes" type="number" min="0" step="1" value="0" style="width:90px;">
        </label>

        <button type="button" onclick="startTaskTimer()">Timer starten</button>
        <button type="button" onclick="stopTaskTimer()">Stop</button>
      </div>

      <div id="timer" style="margin-top:10px; font-size:18px;"></div>
    </div>
  </div>

  <button onclick="nextPlayer()">Nächster Spieler</button>
</div>

<script>
/* =========================
   STATE
========================= */
let players = [];
let currentIndex = 0;
let tasks = [];

/* =========================
   HELPERS
========================= */
function norm(s){ return (s ?? "").toString().trim(); }

function lower(s){ return norm(s).toLowerCase(); }

function splitList(cell){
  const s = lower(cell);
  if(!s) return [];
  // akzeptiert "homo, bi, pan" oder "homo,bi,pan"
  return s.split(",").map(x=>x.trim()).filter(Boolean);
}

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function formatNames(names){
  if(!names || names.length===0) return "";
  if(names.length===1) return names[0];
  if(names.length===2) return `${names[0]} & ${names[1]}`;
  return `${names.slice(0,-1).join(", ")} & ${names[names.length-1]}`;
}

function hideTargets(){
  const box = document.getElementById("targetsBox");
  box.style.display = "none";
  box.innerHTML = "";
}

function showTargets(names){
  const box = document.getElementById("targetsBox");
  if(!names || names.length === 0){
    hideTargets();
    return;
  }
  box.style.display = "block";
  box.innerHTML = `<b>Beteiligte:</b> ${formatNames(names)}`;
}

/* =========================
   PLAYER SETUP UI
========================= */
function setPlayerCount(){
  const n = parseInt(document.getElementById("playerCount").value, 10);
  const container = document.getElementById("players");
  container.innerHTML = "";
  for(let i=0;i<n;i++) addPlayerRow();
}

function addPlayerRow(){
  const container = document.getElementById("players");
  const div = document.createElement("div");
  div.innerHTML = `
    <input placeholder="Name" style="width:170px;">
    <select style="width:120px;">
      <option>männlich</option>
      <option>weiblich</option>
      <option>nonbinär</option>
    </select>
    <select style="width:120px;">
      <option>hetero</option>
      <option>homo</option>
      <option>bi</option>
      <option>pan</option>
      <option>offen</option>
    </select>
  `;
  container.appendChild(div);
}

/* =========================
   CSV LOAD (semicolon; tolerant)
========================= */
async function loadTasks(){
  const response = await fetch('fragen.csv', { cache: "no-store" });
  if(!response.ok) throw new Error("fragen.csv nicht gefunden (muss neben index.html liegen).");
  const data = await response.text();
  const lines = data.split(/\r?\n/).filter(l => l.trim().length > 0);
  const header = lines.shift() || "";
  const sep = header.includes(";") ? ";" : ",";

  tasks = lines.map(line => {
    const cols = line.split(sep).map(c => norm(c));
    // expected: type;text;level;wer;allowed;target;timer;zieltyp
    return {
      type: cols[0] || "",
      text: cols[1] || "",
      level: parseInt(cols[2] || "0", 10) || 0,
      wer: lower(cols[3] || "alle"),
      allowedRaw: cols[4] || "alle",
      allowed: lower(cols[4] || "alle"), // string
      target: lower(cols[5] || "alle"),
      timer: parseInt(cols[6] || "0", 10) || 0,
      zieltyp: norm(cols[7] || "Selbst") || "Selbst"
    };
  }).filter(t => t.type && t.text && t.level > 0);
}

/* =========================
   GAME FLOW
========================= */
function startGame(){
  const rows = document.getElementById("players").children;
  players = [];

  for(const r of rows){
    const name = norm(r.children[0].value);
    const gender = norm(r.children[1].value);
    const orientation = norm(r.children[2].value);
    if(name){
      players.push({name, gender, orientation});
    }
  }

  if(players.length < 2){
    alert("Mindestens 2 Spieler (mit Namen)!");
    return;
  }

  currentIndex = 0;
  document.getElementById("setup").classList.add("hidden");
  document.getElementById("game").classList.remove("hidden");
  document.getElementById("currentPlayer").innerText = players[currentIndex].name + " ist dran";

  document.getElementById("result").classList.add("hidden");
  hideTargets();
  stopTaskTimer();
}

function nextPlayer(){
  currentIndex = (currentIndex + 1) % players.length;
  document.getElementById("currentPlayer").innerText = players[currentIndex].name + " ist dran";
  document.getElementById("result").classList.add("hidden");
  hideTargets();
  stopTaskTimer();
}

/* =========================
   STRICT MATCHING LOGIC
========================= */

// 1) Allowed: "alle" oder "offen" => alle, sonst Liste muss active.orientation exakt enthalten
function allowedMatches(task, active){
  const a = lower(task.allowed);
  if(a === "alle" || a === "offen") return true;
  const list = splitList(task.allowedRaw);
  return list.includes(lower(active.orientation));
}

// 2) Wer: "alle" oder exakt active.gender
function werMatches(task, active){
  const w = lower(task.wer);
  if(w === "alle") return true;
  return w === lower(active.gender);
}

// 3) mögliche Targets (andere Spieler), nach Gender-Regel target ("alle" oder genau gender)
function eligibleTargets(task, activeIndex){
  const active = players[activeIndex];
  const others = players
    .map((p, idx)=>({ ...p, idx }))
    .filter(p => p.idx !== activeIndex);

  const tgt = lower(task.target);
  if(tgt === "alle") return others;
  return others.filter(o => lower(o.gender) === tgt);
}

// 4) zieltyp -> benötigte Anzahl Targets
function requiredTargetCount(zieltyp, eligibleCount){
  const z = norm(zieltyp) || "Selbst";
  if(z === "Selbst") return 0;
  if(z === "Einzel") return 1;
  if(z === "Zwei") return 2;
  if(z === "Gruppe") return Math.max(1, eligibleCount); // mindestens 1 sinnvoll
  if(z === "BeliebigViele") return Math.min(2, eligibleCount); // Mindestlogik: 2, wenn möglich
  return 0;
}

// 5) konkrete Targets ziehen (Namen)
function pickTargets(task, activeIndex){
  const z = norm(task.zieltyp) || "Selbst";
  const pool = shuffle(eligibleTargets(task, activeIndex));

  if(z === "Selbst") return [];

  if(z === "Einzel"){
    return pool.slice(0,1).map(x=>x.name);
  }
  if(z === "Zwei"){
    return pool.slice(0,2).map(x=>x.name);
  }
  if(z === "Gruppe"){
    return pool.map(x=>x.name);
  }
  if(z === "BeliebigViele"){
    const n = pool.length;
    if(n <= 2) return pool.map(x=>x.name);
    const count = 2 + Math.floor(Math.random() * (n - 1)); // 2..n
    return pool.slice(0, count).map(x=>x.name);
  }
  return [];
}

// 6) Gesamtfilter: type exakt, level exakt, allowed strikt, wer strikt, und Zieltyp muss erfüllbar sein
function isTaskValid(task, type, level, activeIndex){
  const active = players[activeIndex];

  if(norm(task.type) !== norm(type)) return false;
  if(Number(task.level) !== Number(level)) return false; // EXAKT

  if(!allowedMatches(task, active)) return false;
  if(!werMatches(task, active)) return false;

  const eligible = eligibleTargets(task, activeIndex);
  const need = requiredTargetCount(task.zieltyp, eligible.length);

  // Wenn need > 0, müssen auch genug Targets da sein
  if(need > 0 && eligible.length < need) return false;

  // Gruppe braucht zumindest 1 eligible (sonst sinnlos)
  if(norm(task.zieltyp) === "Gruppe" && eligible.length < 1) return false;

  return true;
}

/* =========================
   DRAW
========================= */
function draw(type){
  const level = Number(document.getElementById("level").value) || 1;

  const valid = tasks.filter(t => isTaskValid(t, type, level, currentIndex));

  if(valid.length === 0){
    alert("Keine passende Aufgabe gefunden (für diesen Level/Spieler/Konstellation).");
    return;
  }

  const chosen = valid[Math.floor(Math.random() * valid.length)];

  document.getElementById("taskText").innerText = chosen.text;
  document.getElementById("result").classList.remove("hidden");

  const targets = pickTargets(chosen, currentIndex);
  showTargets(targets);

  // Timer reset
  stopTaskTimer();
  document.getElementById("timer").innerText = "";
  document.getElementById("timerInputMinutes").value = "0";
}

/* =========================
   TIMER
========================= */
let taskTimerInterval = null;
let taskTimerRemaining = 0;

function setTimerMinutes(min) {
  document.getElementById("timerInputMinutes").value = String(min);
}

function startTaskTimer() {
  stopTaskTimer();

  const mins = parseInt(document.getElementById("timerInputMinutes").value || "0", 10);
  if (!mins || mins <= 0) {
    document.getElementById("timer").innerText = "";
    alert("Bitte Minuten > 0 einstellen.");
    return;
  }

  taskTimerRemaining = mins * 60;
  renderTaskTimer();

  taskTimerInterval = setInterval(() => {
    taskTimerRemaining--;
    renderTaskTimer();

    if (taskTimerRemaining <= 0) {
      stopTaskTimer();
      document.getElementById("timer").innerText = "Zeit!";
    }
  }, 1000);
}

function stopTaskTimer() {
  if (taskTimerInterval) {
    clearInterval(taskTimerInterval);
    taskTimerInterval = null;
  }
}

function renderTaskTimer() {
  const m = Math.floor(taskTimerRemaining / 60);
  const s = taskTimerRemaining % 60;
  document.getElementById("timer").innerText =
    "Timer: " + String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}

/* =========================
   INIT
========================= */
(async function init(){
  setPlayerCount(); // baut Eingabefelder passend zur Dropdown-Zahl
  try{
    await loadTasks();
  }catch(e){
    alert(String(e.message || e));
  }
})();
</script>

</body>
</html>
