<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Wahrheit oder Pflicht</title>
<style>
  body { font-family: Arial, sans-serif; background:#111; color:white; text-align:center; padding:20px;}
  button { padding:12px 20px; margin:10px; font-size:16px; cursor:pointer;}
  select, input { padding:8px; margin:5px;}
  .card { margin-top:20px; padding:20px; background:#222; border-radius:10px;}
  .hidden { display:none; }
  #targetsBox{
    margin-top:10px;
    font-size:14px;
    opacity:.92;
    padding:10px 12px;
    background:#1a1a1a;
    border:1px solid #333;
    border-radius:10px;
    display:none;
  }
</style>
</head>
<body>

<h1>Wahrheit oder Pflicht</h1>

<div id="setup">
  <h3>Spieleranzahl</h3>
  <select id="playerCount"></select>
  <button type="button" onclick="applyPlayerCount()">Anwenden</button>

  <h2>Spieler hinzufügen</h2>
  <div id="players"></div>
  <button type="button" onclick="addPlayer()">+ Spieler</button>

  <h3>Level (strikt)</h3>
  <select id="level">
    <option value="1">1 - Sanft</option>
    <option value="2">2 - Mittel</option>
    <option value="3">3 - Direkt</option>
    <option value="4">4 - Heavy</option>
    <option value="5">5 - Pervers & Dirty</option>
  </select>
  <br><br>

  <button type="button" onclick="startGame()">Spiel starten</button>
</div>

<div id="game" class="hidden">
  <h2 id="currentPlayer"></h2>

  <button type="button" onclick="draw('Wahrheit')">Wahrheit</button>
  <button type="button" onclick="draw('Pflicht')">Pflicht</button>

  <div id="result" class="card hidden">
    <p id="taskText"></p>
    <div id="targetsBox"></div>

    <div style="margin-top:12px;">
      <div style="margin-bottom:8px;">
        <button type="button" onclick="setTimerMinutes(1)">1 min</button>
        <button type="button" onclick="setTimerMinutes(3)">3 min</button>
        <button type="button" onclick="setTimerMinutes(5)">5 min</button>
      </div>

      <div style="display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap;">
        <label style="font-size:14px;">
          Minuten:
          <input id="timerInputMinutes" type="number" min="0" step="1" value="0" style="width:90px;">
        </label>

        <button type="button" onclick="startTaskTimer()">Timer starten</button>
        <button type="button" onclick="stopTaskTimer()">Stop</button>
      </div>

      <div id="timer" style="margin-top:10px; font-size:18px;"></div>
    </div>
  </div>

  <button type="button" onclick="nextPlayer()">Nächster Spieler</button>
</div>

<script>
/**
 * CSV-Format (Semikolon getrennt):
 * type;text;level;wer;allowed;target;timer;zieltyp
 *
 * type: Wahrheit | Pflicht
 * level: 1..5 (strikt)
 * wer: männlich | weiblich | nonbinär | alle
 * allowed: hetero | homo | bi | pan | offen | alle (mehrere per Komma möglich)
 * target: männlich | weiblich | nonbinär | alle   (Filter für die beteiligten Targets)
 * timer: Sekunden oder 0 (wird hier NICHT automatisch gestartet – nur als Datenfeld)
 * zieltyp: Selbst | Einzel | Zwei | Gruppe | BeliebigViele
 */

let players = [];
let currentIndex = 0;
let tasks = [];

const $ = (id) => document.getElementById(id);

function normalize(s){ return String(s ?? "").trim().toLowerCase(); }

function tokenizeList(s){
  const raw = normalize(s);
  if(!raw) return [];
  // akzeptiert: "homo, bi" oder "homo bi" oder "homo|bi"
  return raw.split(/[,\|]/).map(x=>x.trim()).filter(Boolean)
    .flatMap(x => x.split(/\s+/).map(y=>y.trim()).filter(Boolean));
}

function formatNames(names){
  if(!names || names.length===0) return "";
  if(names.length===1) return names[0];
  if(names.length===2) return `${names[0]} & ${names[1]}`;
  return `${names.slice(0,-1).join(", ")} & ${names[names.length-1]}`;
}

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

// ---------------- CSV Laden ----------------
async function loadTasks(){
  const response = await fetch('fragen.csv', { cache: "no-store" });
  if(!response.ok) throw new Error("fragen.csv nicht gefunden (muss im selben Ordner liegen).");
  const data = await response.text();

  const lines = data.split(/\r?\n/).filter(l => l.trim().length > 0);
  if(lines.length < 2) throw new Error("fragen.csv ist leer oder hat nur Header.");

  // Header entfernen
  const header = lines.shift();
  const sep = header.includes(";") ? ";" : ",";

  tasks = lines.map(line => {
    const cols = line.split(sep).map(c => (c ?? "").trim());
    return {
      type: (cols[0] || "").trim(),
      text: (cols[1] || "").trim(),
      level: parseInt(cols[2] || "0", 10) || 0,
      wer: (cols[3] || "alle").trim(),
      allowed: (cols[4] || "alle").trim(),
      target: (cols[5] || "alle").trim(),
      timer: parseInt(cols[6] || "0", 10) || 0,
      zieltyp: (cols[7] || "Selbst").trim()
    };
  }).filter(t => t.type && t.text && t.level > 0);
}

// ---------------- Spieler UI ----------------
function buildPlayerCountOptions(){
  const sel = $("playerCount");
  sel.innerHTML = "";
  const opts = [2,3,4,5,6,7,8,9,10];
  for(const n of opts){
    const o = document.createElement("option");
    o.value = String(n);
    o.textContent = String(n);
    sel.appendChild(o);
  }
  sel.value = "2";
}

function addPlayer(){
  const container = $("players");
  const div = document.createElement("div");
  div.style.marginBottom = "6px";
  div.innerHTML = `
    <input placeholder="Name" style="width:160px">
    <select style="width:120px">
      <option>männlich</option>
      <option>weiblich</option>
      <option>nonbinär</option>
    </select>
    <select style="width:110px">
      <option>hetero</option>
      <option>homo</option>
      <option>bi</option>
      <option>pan</option>
      <option>offen</option>
    </select>
  `;
  container.appendChild(div);

  // Dropdown Spieleranzahl automatisch anpassen (falls du +Spieler nutzt)
  const countSel = $("playerCount");
  const n = container.children.length;
  if([...countSel.options].some(o=>Number(o.value)===n)) countSel.value = String(n);
}

function applyPlayerCount(){
  const n = parseInt($("playerCount").value, 10);
  const container = $("players");
  container.innerHTML = "";
  for(let i=0;i<n;i++) addPlayer();
}

// ---------------- Start / Next ----------------
function startGame(){
  const rows = $("players").children;
  players = [];

  for(const row of rows){
    const name = row.children[0].value.trim();
    const gender = row.children[1].value;        // exakt so wie im CSV: männlich/weiblich/nonbinär
    const orientation = row.children[2].value;   // hetero/homo/bi/pan/offen
    if(name){
      players.push({name, gender, orientation});
    }
  }

  if(players.length < 2){
    alert("Mindestens 2 Spieler (mit Namen)!");
    return;
  }

  currentIndex = 0;
  $("setup").classList.add("hidden");
  $("game").classList.remove("hidden");
  $("currentPlayer").innerText = players[currentIndex].name + " ist dran";
}

function nextPlayer(){
  currentIndex = (currentIndex + 1) % players.length;
  $("currentPlayer").innerText = players[currentIndex].name + " ist dran";
  $("result").classList.add("hidden");
  hideTargets();
  stopTaskTimer();
}

// ---------------- Targets (Mehrspieler) ----------------
function hideTargets(){
  const box = $("targetsBox");
  box.style.display = "none";
  box.innerHTML = "";
}

function showTargets(names){
  const box = $("targetsBox");
  if(!names || names.length === 0){
    hideTargets();
    return;
  }
  box.style.display = "block";
  box.innerHTML = `<b>Beteiligte:</b> ${formatNames(names)}`;
}

/**
 * Ziel-Filter:
 * - task.target filtert die GENDER der Targets (männlich/weiblich/nonbinär/alle)
 * - task.zieltyp bestimmt WIE VIELE Targets nötig sind
 */
function eligibleTargetsForTask(task, activeIndex){
  const others = players
    .map((p, idx) => ({...p, idx}))
    .filter(p => p.idx !== activeIndex);

  const targetWanted = normalize(task.target || "alle");
  return others.filter(o => targetWanted === "alle" || normalize(o.gender) === targetWanted);
}

function requiredTargetCount(zieltyp){
  const z = normalize(zieltyp || "selbst");
  if(z === "selbst") return 0;
  if(z === "einzel") return 1;
  if(z === "zwei") return 2;
  if(z === "gruppe") return 1;         // braucht mind. 1 Target (nimmt dann alle passenden)
  if(z === "beliebigviele") return 2;  // mind. 2 Targets
  return 0;
}

function pickTargetsForTask(task, activeIndex){
  const z = normalize(task.zieltyp || "Selbst");
  const pool = shuffle(eligibleTargetsForTask(task, activeIndex));

  if(z === "selbst") return [];
  if(z === "einzel") return pool.slice(0, 1).map(x => x.name);
  if(z === "zwei")   return pool.slice(0, 2).map(x => x.name);
  if(z === "gruppe") return pool.map(x => x.name);

  if(z === "beliebigviele"){
    const n = pool.length;
    if(n <= 2) return pool.map(x => x.name);
    const count = 2 + Math.floor(Math.random() * (n - 1)); // 2..n
    return pool.slice(0, count).map(x => x.name);
  }
  return [];
}

// ---------------- Strikte Filter ----------------
function taskAllowedForActive(task, active){
  // 1) Typ muss passen
  // 2) Level MUSS exakt passen
  // 3) "wer" MUSS passen (männlich/weiblich/nonbinär/alle)
  // 4) "allowed" MUSS passen (Orientierung: keine Ausnahmen)
  const wer = normalize(task.wer || "alle");
  const activeGender = normalize(active.gender);

  if(wer !== "alle" && wer !== activeGender) return false;

  const allowedTokens = tokenizeList(task.allowed || "alle");
  const activeOri = normalize(active.orientation);

  if(allowedTokens.length === 0) return true;         // leeres Feld = egal
  if(allowedTokens.includes("alle")) return true;     // alle = jeder
  // strikt:
  return allowedTokens.includes(activeOri);
}

function taskHasEnoughTargets(task, activeIndex){
  const need = requiredTargetCount(task.zieltyp);
  if(need === 0) return true;
  const eligibleCount = eligibleTargetsForTask(task, activeIndex).length;
  return eligibleCount >= need;
}

// ---------------- Draw ----------------
function draw(type){
  const level = Number($("level").value) || 1;
  const active = players[currentIndex];

  // STRIKT: level muss exakt matchen
  const validTasks = tasks.filter(t => {
    if(t.type !== type) return false;
    if(Number(t.level) !== level) return false;             // <- STRIKT
    if(!taskAllowedForActive(t, active)) return false;      // <- STRIKT
    if(!taskHasEnoughTargets(t, currentIndex)) return false;
    return true;
  });

  if(validTasks.length === 0){
    alert("Keine passende Aufgabe gefunden (Filter sind strikt).");
    return;
  }

  const chosen = validTasks[Math.floor(Math.random() * validTasks.length)];

  $("taskText").innerText = chosen.text;
  $("result").classList.remove("hidden");

  const targetNames = pickTargetsForTask(chosen, currentIndex);
  showTargets(targetNames);

  // Timer reset (manuell)
  stopTaskTimer();
  $("timer").innerText = "";
  $("timerInputMinutes").value = "0";
}

// ---------------- Timer ----------------
let taskTimerInterval = null;
let taskTimerRemaining = 0;

function setTimerMinutes(min) {
  $("timerInputMinutes").value = String(min);
}

function startTaskTimer() {
  stopTaskTimer();
  const mins = parseInt($("timerInputMinutes").value || "0", 10);

  if (!mins || mins <= 0) {
    $("timer").innerText = "";
    alert("Bitte Minuten > 0 einstellen.");
    return;
  }

  taskTimerRemaining = mins * 60;
  renderTaskTimer();

  taskTimerInterval = setInterval(() => {
    taskTimerRemaining--;
    renderTaskTimer();

    if (taskTimerRemaining <= 0) {
      stopTaskTimer();
      $("timer").innerText = "Zeit!";
    }
  }, 1000);
}

function stopTaskTimer() {
  if (taskTimerInterval) {
    clearInterval(taskTimerInterval);
    taskTimerInterval = null;
  }
}

function renderTaskTimer() {
  const m = Math.floor(taskTimerRemaining / 60);
  const s = taskTimerRemaining % 60;
  $("timer").innerText = "Timer: " + String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}

// ---------------- Init ----------------
(async function init(){
  buildPlayerCountOptions();
  applyPlayerCount();

  try{
    await loadTasks();
  } catch(e){
    console.error(e);
    alert(String(e.message || e));
  }
})();
</script>

</body>
</html>
