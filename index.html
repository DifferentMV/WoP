<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Wahrheit oder Pflicht</title>
<style>
  body { font-family: Arial, sans-serif; background:#111; color:#fff; text-align:center; padding:20px; }
  button { padding:12px 20px; margin:10px; font-size:16px; cursor:pointer; }
  select, input { padding:8px; margin:5px; }
  .card { margin:20px auto 0; padding:20px; background:#222; border-radius:10px; max-width:900px; }
  .hidden { display:none; }
  #players > div { margin:10px 0; }
  #targetsBox{
    margin-top:10px;
    font-size:14px;
    opacity:.92;
    padding:10px 12px;
    background:#1a1a1a;
    border:1px solid #333;
    border-radius:10px;
    display:none;
  }
  #debugBox{
    margin:12px auto 0;
    max-width:900px;
    text-align:left;
    font-size:13px;
    color:#ddd;
    background:#181818;
    border:1px solid #2a2a2a;
    border-radius:10px;
    padding:10px 12px;
    display:none;
  }
  .row { display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap; }
</style>
</head>
<body>

<h1>Wahrheit oder Pflicht</h1>

<div id="setup">
  <h3>Spieleranzahl</h3>
  <select id="playerCount">
    <option value="2" selected>2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="8">8</option>
  </select>

  <h2>Spieler hinzufügen</h2>
  <div id="players"></div>

  <h3>Level (exakt)</h3>
  <select id="level">
    <option value="1">1 - Sanft</option>
    <option value="2">2 - Mittel</option>
    <option value="3">3 - Direkt</option>
    <option value="4">4 - Heavy</option>
    <option value="5">5 - Pervers & Dirty</option>
  </select>

  <br><br>
  <button id="btnStart">Spiel starten</button>
  <div id="debugBox"></div>
</div>

<div id="game" class="hidden">
  <h2 id="currentPlayer"></h2>

  <button id="btnTruth">Wahrheit</button>
  <button id="btnDare">Pflicht</button>

  <div id="result" class="card hidden">
    <p id="taskText" style="font-size:18px;"></p>
    <div id="targetsBox"></div>

    <div style="margin-top:12px;">
      <div style="margin-bottom:8px;">
        <button type="button" onclick="setTimerMinutes(1)">1 min</button>
        <button type="button" onclick="setTimerMinutes(3)">3 min</button>
        <button type="button" onclick="setTimerMinutes(5)">5 min</button>
      </div>

      <div class="row">
        <label style="font-size:14px;">
          Minuten:
          <input id="timerInputMinutes" type="number" min="0" step="1" value="0" style="width:90px;">
        </label>

        <button type="button" onclick="startTaskTimer()">Timer starten</button>
        <button type="button" onclick="stopTaskTimer()">Stop</button>
      </div>

      <div id="timer" style="margin-top:10px; font-size:18px;"></div>
    </div>
  </div>

  <button id="btnNext">Nächster Spieler</button>
</div>

<script>
/* ==========================
   Utils / Normalisierung
========================== */
const norm = (s) => String(s ?? "").trim().toLowerCase();

function normGender(s){
  const v = norm(s);
  if(v === "m" || v === "mann" || v === "male") return "männlich";
  if(v === "w" || v === "frau" || v === "female") return "weiblich";
  if(v === "nb" || v === "nonbinary" || v === "non-binär") return "nonbinär";
  if(v === "männlich" || v === "weiblich" || v === "nonbinär" || v === "alle") return v;
  return v; // wenn du später was ergänzt
}

function normZieltyp(s){
  const v = norm(s);
  if(!v) return "selbst";
  if(v === "selbst") return "selbst";
  if(v === "einzel") return "einzel";
  if(v === "zwei") return "zwei";
  if(v === "gruppe") return "gruppe";
  if(v === "beliebigviele" || v === "beliebig viele") return "beliebigviele";
  return v;
}

function allowedSet(s){
  // allowed: "alle" | "offen" | "hetero" | "homo" | "bi" | "pan" | "homo,bi,pan"
  const v = norm(s);
  if(!v || v === "alle") return new Set(["alle"]);
  return new Set(v.split(",").map(x => norm(x)).filter(Boolean));
}

function showDebug(msg){
  const box = document.getElementById("debugBox");
  if(!msg){
    box.style.display="none";
    box.textContent="";
    return;
  }
  box.style.display="block";
  box.textContent = msg;
}

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function formatNames(names){
  if(!names || names.length===0) return "";
  if(names.length===1) return names[0];
  if(names.length===2) return `${names[0]} & ${names[1]}`;
  return `${names.slice(0,-1).join(", ")} & ${names[names.length-1]}`;
}

/* ==========================
   State
========================== */
let players = [];
let currentIndex = 0;
let tasks = [];

/* ==========================
   CSV Laden (strikt)
========================== */
async function loadTasks(){
  const res = await fetch("fragen.csv", { cache: "no-store" });
  if(!res.ok) throw new Error("fragen.csv nicht gefunden oder nicht erreichbar.");
  const text = await res.text();
  const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);

  // Header
  lines.shift();

  tasks = lines.map(line => {
    const cols = line.split(";").map(c => String(c ?? ""));
    // type;text;level;wer;allowed;target;timer;zieltyp
    return {
      type: cols[0] ?? "",
      text: cols[1] ?? "",
      level: Number(String(cols[2] ?? "").trim()) || 0,
      wer: normGender(cols[3]),
      allowedRaw: cols[4] ?? "alle",
      allowed: allowedSet(cols[4]),
      target: normGender(cols[5] ?? "alle"),
      timer: Number(String(cols[6] ?? "").trim()) || 0, // Sekunden (optional)
      zieltyp: normZieltyp(cols[7])
    };
  }).filter(t => norm(t.type) && norm(t.text) && t.level > 0);
}

/* ==========================
   Spieler Setup UI
========================== */
function renderPlayers(n){
  const container = document.getElementById("players");
  container.innerHTML = "";
  for(let i=0;i<n;i++){
    const div = document.createElement("div");
    div.innerHTML = `
      <input placeholder="Name" value="${i===0 ? "M1" : i===1 ? "W1" : "P"+(i+1)}">
      <select>
        <option>männlich</option>
        <option>weiblich</option>
        <option>nonbinär</option>
      </select>
      <select>
        <option>hetero</option>
        <option>homo</option>
        <option>bi</option>
        <option>pan</option>
        <option>offen</option>
      </select>
    `;
    container.appendChild(div);
  }
}

function readPlayers(){
  const rows = document.getElementById("players").children;
  const out = [];
  for(const row of rows){
    const name = row.children[0].value.trim();
    const gender = normGender(row.children[1].value);
    const orientation = norm(row.children[2].value);
    if(name) out.push({ name, gender, orientation });
  }
  return out;
}

/* ==========================
   Targets / Logik (strikt)
========================== */
function eligibleTargets(task, activeIndex){
  const active = players[activeIndex];
  const others = players
    .map((p, idx) => ({...p, idx}))
    .filter(p => p.idx !== activeIndex);

  // Gender-Target: alle oder match
  const tGender = normGender(task.target);
  let pool = others.filter(o => tGender === "alle" || o.gender === tGender);

  // HARTE SPERRE: hetero bekommt niemals same-gender pairing (wenn überhaupt Targets nötig)
  // (Bei zieltyp=selbst egal)
  const z = task.zieltyp;
  if(z !== "selbst"){
    if(active.orientation === "hetero"){
      pool = pool.filter(o => o.gender !== active.gender);
    }
  }

  return pool;
}

function requiredCount(zieltyp){
  switch(zieltyp){
    case "einzel": return 1;
    case "zwei": return 2;
    case "gruppe": return 1;        // braucht mind. 1 Target (zeigt dann alle)
    case "beliebigviele": return 2; // mind. 2
    default: return 0;              // selbst
  }
}

function pickTargets(task, activeIndex){
  const z = task.zieltyp;
  const pool = shuffle(eligibleTargets(task, activeIndex));

  if(z === "selbst") return [];
  if(z === "einzel") return pool.slice(0,1).map(x => x.name);
  if(z === "zwei") return pool.slice(0,2).map(x => x.name);
  if(z === "gruppe") return pool.map(x => x.name); // ALLE
  if(z === "beliebigviele"){
    const n = pool.length;
    if(n < 2) return [];
    const count = 2 + Math.floor(Math.random() * (n - 1)); // 2..n
    return pool.slice(0, count).map(x => x.name);
  }
  return [];
}

function matchesStrict(task, type, chosenLevel, activeIndex){
  const active = players[activeIndex];

  // Type
  if(norm(task.type) !== norm(type)) return false;

  // LEVEL exakt
  if(task.level !== chosenLevel) return false;

  // "wer" (aktiver Spieler) muss passen
  const wer = normGender(task.wer);
  if(!(wer === "alle" || wer === active.gender)) return false;

  // Allowed (Orientierung des aktiven)
  // allowed=alle -> immer
  // allowed=offen -> immer (dein Wunsch: "offen" ist nicht restriktiv)
  // sonst muss active.orientation drin sein
  if(!(task.allowed.has("alle") || task.allowed.has("offen") || task.allowed.has(active.orientation))) return false;

  // Zieltyp / Targets machbar?
  const z = task.zieltyp;
  const pool = eligibleTargets(task, activeIndex);
  const need = requiredCount(z);
  if(pool.length < need) return false;

  return true;
}

/* ==========================
   UI: Targets anzeigen
========================== */
function hideTargets(){
  const box = document.getElementById("targetsBox");
  box.style.display = "none";
  box.innerHTML = "";
}

function showTargets(names){
  const box = document.getElementById("targetsBox");
  if(!names || names.length === 0){
    hideTargets();
    return;
  }
  box.style.display = "block";
  box.innerHTML = `<b>Beteiligte:</b> ${formatNames(names)}`;
}

/* ==========================
   Game Flow
========================== */
function startGame(){
  players = readPlayers();
  if(players.length < 2){
    alert("Mindestens 2 Spieler!");
    return;
  }
  currentIndex = 0;
  document.getElementById("setup").classList.add("hidden");
  document.getElementById("game").classList.remove("hidden");
  document.getElementById("currentPlayer").innerText = players[currentIndex].name + " ist dran";
}

function nextPlayer(){
  currentIndex = (currentIndex + 1) % players.length;
  document.getElementById("currentPlayer").innerText = players[currentIndex].name + " ist dran";
  document.getElementById("result").classList.add("hidden");
  hideTargets();
  stopTaskTimer();
}

function draw(type){
  const chosenLevel = Number(document.getElementById("level").value) || 1;

  const valid = tasks.filter(t => matchesStrict(t, type, chosenLevel, currentIndex));

  if(valid.length === 0){
    alert("Keine passende Aufgabe gefunden (strikt).");
    return;
  }

  const task = valid[Math.floor(Math.random() * valid.length)];

  document.getElementById("taskText").innerText = task.text;
  document.getElementById("result").classList.remove("hidden");

  // Targets
  const targetNames = pickTargets(task, currentIndex);
  showTargets(targetNames);

  // Timer reset + optional aus CSV (Sekunden -> Minuten aufrunden)
  stopTaskTimer();
  document.getElementById("timer").innerText = "";
  if(task.timer && task.timer > 0){
    const mins = Math.max(1, Math.ceil(task.timer / 60));
    document.getElementById("timerInputMinutes").value = String(mins);
  } else {
    document.getElementById("timerInputMinutes").value = "0";
  }
}

/* ==========================
   Timer
========================== */
let taskTimerInterval = null;
let taskTimerRemaining = 0;

function setTimerMinutes(min) {
  document.getElementById("timerInputMinutes").value = String(min);
}

function startTaskTimer() {
  stopTaskTimer();

  const mins = parseInt(document.getElementById("timerInputMinutes").value || "0", 10);
  if (!mins || mins <= 0) {
    document.getElementById("timer").innerText = "";
    alert("Bitte Minuten > 0 einstellen.");
    return;
  }

  taskTimerRemaining = mins * 60;
  renderTaskTimer();

  taskTimerInterval = setInterval(() => {
    taskTimerRemaining--;
    renderTaskTimer();

    if (taskTimerRemaining <= 0) {
      stopTaskTimer();
      document.getElementById("timer").innerText = "Zeit!";
    }
  }, 1000);
}

function stopTaskTimer() {
  if (taskTimerInterval) {
    clearInterval(taskTimerInterval);
    taskTimerInterval = null;
  }
}

function renderTaskTimer() {
  const m = Math.floor(taskTimerRemaining / 60);
  const s = taskTimerRemaining % 60;
  document.getElementById("timer").innerText =
    "Timer: " + String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
}

/* ==========================
   Init
========================== */
(async function init(){
  try{
    await loadTasks();
  } catch(e){
    showDebug("CSV-Fehler: " + (e?.message || String(e)));
  }

  // Setup PlayerCount
  const pc = document.getElementById("playerCount");
  const applyCount = () => renderPlayers(parseInt(pc.value, 10) || 2);
  pc.addEventListener("change", applyCount);
  applyCount();

  // Buttons
  document.getElementById("btnStart").addEventListener("click", startGame);
  document.getElementById("btnNext").addEventListener("click", nextPlayer);
  document.getElementById("btnTruth").addEventListener("click", () => draw("Wahrheit"));
  document.getElementById("btnDare").addEventListener("click", () => draw("Pflicht"));
})();
</script>

</body>
</html>
